Using `maptools` - Proof of concept
===================================

Download TIGER 2012 shapefiles [here](http://www.census.gov/geo/maps-data/data/tiger-line.html). Store the shapefiles on the CHSE server in the "`DataRepository/Shapefiles/TIGER 2012`" folder. 

Resources:
* [Combining Spatial Data](http://cran.r-project.org/web/packages/maptools/vignettes/combine_maptools.pdf)
* [Maps in R -- Examples](http://geography.uoregon.edu/geogr/topics/maps.htm)
* [adding variable to shapefile](http://r-sig-geo.2731867.n2.nabble.com/adding-variable-to-shapefile-td6193408.html)

Load `maptools`
```{r LoadLibraries}
require(maptools, quietly=TRUE)
require(RColorBrewer, quietly=TRUE)
library(classInt, quietly=TRUE)
```

Read in the TIGER 2012 shapefiles:
* Zip Code Tabulation Area (ZCTA) shapefile
* County shapefile
I'm not sure how the `proj4string` parameter works, but it fixes the projection.
```{r ReadShapefiles}
dir <- "E:/DataRepository/Shapefiles/TIGER 2012/tl_2012_us_zcta510"
file <- paste(dir, "tl_2012_us_zcta510.shp", sep="/")
shpZCTALines <- readShapeLines(file, proj4string=CRS("+proj=longlat"))
shpZCTAPoly <- readShapePoly(file, proj4string=CRS("+proj=longlat"))
dir <- "E:/DataRepository/Shapefiles/TIGER 2012/tl_2012_us_county"
file <- paste(dir, "tl_2012_us_county.shp", sep="/")
shpCountyLines <- readShapeLines(file, proj4string=CRS("+proj=longlat"))
# shpCountyPoly <- readShapePoly(file, proj4string=CRS("+proj=longlat"))
```

Keep only counties in Oregon (`STATE == 41`). Oregon ZCTAs will be extracted following this.
```{r KeepOregon}
shpCountyLines <- subset(shpCountyLines, STATEFP == 41)
summary(shpCountyLines)
```

Since ZCTAs do not exactly correspond to geographical units, we need to read in a ZCTA relationship file that links ZCTAs to states and counties. 
```{r ReadZCTARelFile}
dir <- "E:/DataRepository/Shapefiles/TIGER 2012/ZCTA Relationship Files"
file <- paste(dir, "zcta_county_rel_10.txt", sep="/")
zctarel <- read.table(file, header=TRUE, sep=",")
head(zctarel)
```

Create a character vector of ZCTAs and add it to the ZCTA relationship data frame. Then subset the ZCTA relationship file for Oregon ('STATE == 41' and ZCTA beginning with "97").
```{r SubsetZCTARelFile}
ZCTA5CHR <- sprintf("%05d", zctarel$ZCTA5)
zctarel <- data.frame(ZCTA5CHR, zctarel)
zctarelOR <- zctarel[zctarel$STATE == 41 & grepl("^97", zctarel$ZCTA5CHR),]
head(zctarelOR)
```

Subset the TIGER shapefile to include only the Oregon ZCTAs.
```{r SubsetShapefile}
shpZCTALines <- subset(shpZCTALines, ZCTA5CE10 %in% zctarelOR$ZCTA5)
summary(shpZCTALines)
shpZCTAPoly <- subset(shpZCTAPoly, ZCTA5CE10 %in% zctarelOR$ZCTA5)
summary(shpZCTAPoly)
```

Merge the attributes from the ZCTA relationship file to the Oregon shapefile. Some ZCTAs span across counties. So we'll exclude the attributes that are county-specific; e.g., 2010 Population of the 2010 County (`COPOP`) and Total Area of the 2010 County (`COAREA`). The record file layout can be found [here](http://www.census.gov/geo/maps-data/data/zcta_rel_layout.html).
```{r MergeAttributes}
d1 <- shpZCTAPoly@data
d2 <- subset(zctarelOR, select=c(ZCTA5CHR, ZCTA5, STATE, ZPOP, ZHU, ZAREA, ZAREALAND))
d <- merge(d1, d2, by.x="ZCTA5CE10", by.y="ZCTA5")
shpOR@data <- d
summary(shpOR)
```

Plot the Oregon counties.
```{r MapOR}
plot(shpCountyLines, col="lightgrey")
```

Read in the CCO zip code data compiled by Peter Graven.
```{r ReadCCOData}
lookupCCO <- read.csv("//ohsum01.ohsu.edu/OHSU/OHSU Shared/Restricted/OCHSER/PROJECTS/EX13-04_Oregon_CO&CCOs/CCO Maps/Data/Zip CCO_edit.csv")
lookupCCO <- lookupCCO[order(lookupCCO$Zip_Code),]
head(lookupCCO)
```

Fix some screwed up values.
```{r FixlookupCCO}
lookupCCO$CCO[lookupCCO$CCO == "Health Share of Oregon"] <- "HealthShare of Oregon"
lookupCCO$CCO[lookupCCO$CCO == "Intercommunity"] <- "Intercommunity Health Network"
lookupCCO$CCO[lookupCCO$CCO == "Primary Health of Josephine County"] <- "PrimaryHealth of Josephine County"
lookupCCO$CCO <- factor(lookupCCO$CCO)
```

Get the number of CCOs and create a [Color Brewer](http://colorbrewer2.org/) palette. Since the number of CCOs exceeds the maximum number of values possible in a palette, we'll need to create 3 separate palettes (red, green, blue) and concatenate them. 
```{r CreatePalette}
nCCO <- length(table(lookupCCO$CCO))
n <- ceiling(nCCO / 4)
palR <- brewer.pal(n, "Reds")
palG <- brewer.pal(n, "Greens")
palB <- brewer.pal(n, "Blues")
palP <- brewer.pal(n, "Purples")
pal <- c(palR, palG, palB, palP)
```

Next, assign each CCO to a palette value.
```{r AssignPaletteValues}
CCO <- names(table(lookupCCO$CCO))
pal <- data.frame(CCO, pal)
```

Create color layer, 1 layer per CCO; i.e., `r show(nCCO)` layers
```{r CreateColorLayers, eval=FALSE}
d <- shpZCTAPoly@data
col <- matrix(NA, nrow=nrow(d), ncol=nCCO)
c1 <- d$ZCTA5CE10[d$ZCTA5CE10 %in% lookupCCO$Zip_Code[lookupCCO$CCO == pal$CCO[1]]]
```

Define function to plot each CCO as a layer.
```{r DefineLayeringFunction}
layerCCO <- function(x) {
  l <- lookupCCO[lookupCCO$CCO == x, "Zip_Code"]
  c <- as.character(pal[pal$CCO == x, "pal"])
  shpx <- subset(shpZCTAPoly, ZCTA5CE10 %in% l)
  plot(shpx, add=TRUE, col=c, border=NA)
}
```

Run the layering function, iterating through all the CCOs. The function isn't smart enough to deal with ZCTAs that have multiple CCOs assigned.
```{r MapOregonCCO, fig.keep='last'}
plot(shpZCTALines, col=NA)
for (i in 1:nCCO) {
  layerCCO(CCO[i])
}
```